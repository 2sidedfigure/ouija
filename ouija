#!/usr/bin/env node

"use strict";

var

prog = require('commander'),
pkg = require('./package.json');

prog.version(pkg.version)
    .usage('[options]')
    .option('-p, --port <n>', 'The port to bind the proxy server to, defaults to 6660', parseInt)
    .parse(process.argv);

// if the user hasn't requested help or the version, time to get to work

var

express = require('express'),
phantom = require('node-phantom'),
url = require('url'),
setCookieParser = require('./lib/setcookie').parser,
app = express();

//clear out the default 'x-powered-by' header
app.disable('x-powered-by');

app.use(express.bodyParser());

app.all('*', function(req, res) {
    var params = {
            'disk-cache': true,
            'ignore-ssl-errors': true,
            'max-disk-cache-size': 10*1024 // 10 Mb
        };

    // use a proxy if specified
    ['proxy', 'proxy-type', 'proxy-auth'].forEach(function(p) {
        var header = req.get('ouija-' + p);

        if (header) {
            params[p] = header;
        }
    });

    phantom.create(function(err, ph) {
        // catch when the phantom process exits unexpectedly
        ph.on('exit', function(code, signal) {
            if (code !== 0) {
                console.error(signal);
            }

            res.send(500, 'phantomjs process exited with signal ' + signal);
        });

        ph.createPage(function(err, page) {
            console.log('=> Opening ' + req.url);

            var response, 
                cookies = {},
                customHeaderRE = /^ouija\-pass\-(.*)$/i,
                customHeaders = {},
                parsedUrl = url.parse(req.url),
                sendResponse = function(resBody) {
                    ph.exit();

                    response && response.headers && response.headers.forEach(function(h) {
                        if (!/^set\-cookie/i.test(h.name)) {
                            res.set(h.name, h.value);
                        }
                    });

                    for (var c in cookies) {
                        var cookie = cookies[c];

                        cookie.maxAge && (cookie.maxAge *= 1000);
                        if (cookie.expires && !(cookie.expires instanceof Date)) {
                            cookie.expires = new Date(cookie.expires);
                        }

                        res.cookie(cookies[c].name, cookies[c].value, cookies[c]);
                    }

                    // ensure we have the correct content-length header in case
                    // the DOM has been modified
                    res.set('Content-Length', (new Buffer(resBody)).length);

                    return res.send(response.status || 200, resBody);
                };

            // set the headers to be passed by phantom
            for (var h in req.headers) {
                var match = h.match(customHeaderRE);

                if (match && match[1]) {
                    customHeaders[match[1]] = req.headers[h];
                }
            }
            page.set('customHeaders', customHeaders);

            // NB: need to use the onCallback handler to get around some of the
            // funny scoping that happens when using phantomjs
            //
            // the object argument becomes the primary means of passing data around
            page.onCallback = function(obj) {
                if (obj.response) {
                    var phantomParsedUrl = url.parse(obj.response.url);

                    // compare parsed and formatted urls to account for trailing slashes, etc.
                    if (!response && url.format(phantomParsedUrl) == url.format(parsedUrl)) {
                        response = obj.response;
                    }

                    if (response.headers && phantomParsedUrl.host == parsedUrl.host) {
                        response.headers.forEach(function(h) {
                            if (/^set\-cookie/i.test(h.name)) {
                                var cookies = setCookieParser(h.value);

                                obj.cookies = obj.cookies
                                    ? obj.cookies.concat(cookies)
                                    : cookies;
                            }
                        });
                    }
                }

                if (obj.cookies) {
                    obj.cookies = Array.isArray(obj.cookies)
                        ? obj.cookies
                        : [ obj.cookies ];

                    obj.cookies.forEach(function(c) {
                        if (cookies[c.name]) {
                            // it appears that if a cookie on the page has an expiry
                            // other session cookies on the page (cookies without an
                            // expiry value) will be incorrectly assigned that expiry
                            // when attempting to retrieve the cookies via Phantom's
                            // page.cookie;
                            //
                            // as a compromise we'll only update a cookie's value in
                            // case a script on the page modified the original value
                            // specified by the request headers
                            cookies[c.name].value = c.value;
                        } else {
                            cookies[c.name] = c;
                        }
                    });
                }

                if (obj.next) {
                    if (req.get('ouija-get-unmodified-content')) {
                        ph.createPage(function(err, cachedPage) {
                            cachedPage.set('settings', {
                                javascriptEnabled: false,
                                loadImages: false
                            });

                            cachedPage.set('customHeaders', customHeaders);

                            cachedPage.open(req.url, function(err, status) {
                                cachedPage.get('content', function(err, content) {
                                    sendResponse(content);
                                });
                            });
                        });
                    } else {
                        page.get('content', function(err, content) {
                            sendResponse(content);
                        });
                    }
                }
            };

            page.setFn('onResourceReceived', function(resp) {
                page.onCallback({ 
                    response: resp,
                });
            });

            page.open(req.url, function(err, status) {
                page.get('cookies', function(err, cookieData) {
                    page.onCallback({
                        next: true,
                        cookies: cookieData
                    });
                });
            });
        });

    }, { parameters: params });
});

var server = app.listen(prog.port || 6660),
    address = server.address();

console.log('=> Ouija listening on ' + address.address + ':' + address.port);
